<?php
/**
 * Сервис HTTP-заголовков
 *
 * @author LiverEnemy
 */

class Service_Http_Header extends Service_Abstract
{
    /**
     * HTTP-статус текущего запроса
     *
     * @var int
     */
    protected $_httpStatus = 500;

    /**
     * Множество допустимых HTTP-статусов
     *
     * @var array
     */
    protected static $_httpStatuses = [
        /**
         * Сервер удовлетворён начальными сведениями о запросе, клиент может продолжать пересылать заголовки.
         */
        100 => [
            'code'          => 100,
            'title'         => '100 Continue',
            'description'   => 'Хорошее начало!',
        ],

        /**
         * Сервер предлагает перейти на более подходящий для указанного ресурса протокол;
         * список предлагаемых протоколов сервер обязательно указывает в поле заголовка Update.
         * Если клиента это заинтересует, то он посылает новый запрос с указанием другого протокола.
         */
        101 => [
            'code'          => 101,
            'title'         => '101 Switching Protocols',
            'description'   => 'Перейдите на другой протокол!',
//            'requireParams' => ['Upgrade'],
        ],

        /**
         * Запрос принят, но на его обработку понадобится длительное время.
         * Используется сервером, чтобы клиент не разорвал соединение из-за превышения времени ожидания.
         * Клиент при получении такого ответа должен сбросить таймер и дожидаться следующей команды в обычном режиме.
         */
        102 => [
            'code'          => 102,
            'title'         => '102 Processing',
            'description'   => 'Обработка запроса займет какое-то время.',
        ],

        /**
         * Успешный запрос. Если клиентом были запрошены какие-либо данные,
         * то они находятся в заголовке и/или теле сообщения.
         */
        200 => [
            'code'          => 200,
            'title'         => '200 OK',
            'description'   => 'OK',
        ],

        /**
         * В результате успешного выполнения запроса был создан новый ресурс.
         * Сервер должен указать его местоположение в заголовке Location.
         * Серверу рекомендуется ещё указывать в заголовке характеристики созданного ресурса
         * (например, в поле Content-Type).
         * Если сервер не уверен, что ресурс действительно будет существовать
         * к моменту получения данного сообщения клиентом, то лучше использовать ответ с кодом 202.
         */
        201 => [
            'code'          => 201,
            'title'         => '201 Created',
            'description'   => 'Ресурс успешно создан.',
            'requireParams' => ['Location']
        ],

        /**
         * Запрос был принят на обработку, но она не завершена.
         * Клиенту не обязательно дожидаться окончательной передачи сообщения,
         * так как может быть начат очень долгий процесс.
         */
        202 => [
            'code'          => 202,
            'title'         => '202 Accepted',
            'description'   => 'Обработка запроса займет некоторое время.',
        ],

        /**
         * Аналогично ответу 200, но в этом случае передаваемая информация была взята не из первичного источника,
         * а из резервной копии, с другого сервера и т. д., и поэтому может быть неактуальной.
         */
        203 => [
            'code'          => 203,
            'title'         => '203 Non-Authoritative Information',
            'description'   => 'Информация может быть неактуальной.',
        ],

        /**
         * Сервер успешно обработал запрос, но в ответе были переданы только заголовки без тела сообщения.
         * Клиент не должен обновлять содержимое документа, но может применить к нему полученные метаданные.
         */
        204 => [
            'code'          => 204,
            'title'         => '204 No Content',
            'description'   => 'Мне нечего тебе сказать...',
        ],

        /**
         * Сервер обязывает клиента сбросить введённые пользователем данные.
         * Тела сообщения сервер при этом не передаёт и документ обновлять не обязательно.
         */
        205 => [
            'code'          => 205,
            'title'         => '205 Reset Content',
            'description'   => 'Требуется сбросить введенные данные.',
        ],

        /**
         * Сервер удачно выполнил частичный GET-запрос, возвратив только часть сообщения.
         * В заголовке Content-Range сервер указывает байтовые диапазоны содержимого.
         * Особое внимание при работе с подобными ответами следует уделить кэшированию.
         * @see https://ru.wikipedia.org/wiki/HTTP#.D0.94.D0.BE.D0.BA.D0.B0.D1.87.D0.BA.D0.B0_.D0.B8_.D1.84.D1.80.D0.B0.D0.B3.D0.BC.D0.B5.D0.BD.D1.82.D0.B0.D1.80.D0.BD.D0.BE.D0.B5_.D1.81.D0.BA.D0.B0.D1.87.D0.B8.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5
         */
        206 => [
            'code'          => 206,
            'title'         => '206 Partial Content',
            'description'   => 'Возвращена часть результата.',
            'requireParams' => ['Content-Range'],
        ],

        /**
         * Коды класса 3xx сообщают клиенту, что для успешного выполнения операции необходимо сделать другой запрос,
         * как правило, по другому URI. Из данного класса пять кодов 301, 302, 303, 305 и 307
         * относятся непосредственно к перенаправлениям. Адрес, по которому клиенту следует произвести запрос,
         * сервер указывает в заголовке Location. При этом допускается использование фрагментов в целевом URI.
         *
         * По последним стандартам клиент может производить перенаправление без запроса пользователя,
         * только если второй ресурс будет запрашиваться методом GET или HEAD.
         * В предыдущих спецификациях говорилось, что для избежания круговых переходов
         * пользователя следует спрашивать после 5-го подряд перенаправления.
         * При всех перенаправлениях, если метод запроса был не HEAD,
         * то в тело ответа следует включить короткое гипертекстовое сообщение с целевым адресом,
         * чтобы в случае ошибки пользователь смог сам произвести переход.
         */

        /**
         * По указанному URI существует несколько вариантов предоставления ресурса по типу MIME,
         * по языку или по другим характеристикам. Сервер передаёт с сообщением список альтернатив,
         * давая возможность сделать выбор клиенту автоматически или пользователю.
         */
        300 => [
            'code'          => 300,
            'title'         => '300 Multiple Choices',
            'description'   => 'Есть несколько вариантов представления ресурса.',
        ],

        /**
         * Запрошенный документ был окончательно перенесен на новый URI, указанный в поле Location заголовка.
         * Некоторые клиенты некорректно ведут себя при обработке данного кода.
         *
         * Если метод не GET или HEAD, Спросить у пользователя подтверждения и запросить другой ресурс исходным методом.
         */
        301 => [
            'code'          => 301,
            'title'         => '301 Moved Permanently',
            'description'   => 'Ресурс перемещен постоянно.',
            'requireParams' => ['Location'],
        ],

        /**
         * Запрошенный документ временно доступен по другому URI, указанному в заголовке в поле Location.
         * Этот код может быть использован, например, при управляемом сервером согласовании содержимого.
         * @see https://ru.wikipedia.org/wiki/HTTP#.D0.A3.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D1.8F.D0.B5.D0.BC.D0.BE.D0.B5_.D1.81.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.BE.D0.BC
         *
         * Некоторые клиенты некорректно ведут себя при обработке данного кода.
         * Если метод не GET или HEAD, Спросить у пользователя подтверждения и запросить другой ресурс исходным методом.
         */
        302 => [
            'code'          => 302,
            'title'         => '302 Found',
            'description'   => 'Ресурс временно находится по другому адресу.',
            'requireParams' => ['Location'],
        ],

        /**
         * Документ по запрошенному URI нужно запросить по адресу в поле Location заголовка
         * с использованием метода GET несмотря даже на то, что первый запрашивался иным методом.
         * Этот код был введён вместе с 307-ым для избежания неоднозначности,
         * чтобы сервер был уверен, что следующий ресурс будет запрошен методом GET.
         * Например, на веб-странице есть поле ввода текста для быстрого перехода и поиска.
         * После ввода данных браузер делает запрос методом POST, включая в тело сообщения введённый текст.
         * Если обнаружен документ с введённым названием, то сервер отвечает кодом 303,
         * указав в заголовке Location его постоянный адрес.
         * Тогда браузер гарантировано его запросит методом GET для получения содержимого.
         * В противном случае сервер просто вернёт клиенту страницу с результатами поиска.
         *
         * Если метод не GET или HEAD, Перейти автоматически, но уже методом GET.
         */
        303 => [
            'code'          => 303,
            'title'         => '303 See Other',
            'description'   => 'Найден подходящий ресурс.',
            'requireParams' => ['Location'],
        ],

        /**
         * Сервер возвращает такой код, если клиент запросил документ методом GET,
         * использовал заголовок If-Modified-Since или If-None-Match и документ не изменился с указанного момента.
         * При этом сообщение сервера не должно содержать тела.
         */
        304 => [
            'code'          => 304,
            'title'         => '304 Not Modified',
            'description'   => 'Документ не был изменен.',
        ],

        /**
         * Запрос к запрашиваемому ресурсу должен осуществляться через прокси-сервер,
         * URI которого указан в поле Location заголовка.
         * Данный код ответа могут использовать только исходные HTTP-сервера (не прокси).
         */
        305 => [
            'code'          => 305,
            'title'         => '305 Use Proxy',
            'description'   => 'Необходимо использовать Proxy-сервер.',
            'requireParams' => ['Location'],
        ],

        /**
         * Использовавшийся раньше код ответа в настоящий момент зарезервирован.
         */
        306 => [
            'code'          => 306,
            'title'         => '306 (Unused)',
            'description'   => 'Неиспользуемый статус.',
        ],

        /**
         * Запрашиваемый ресурс на короткое время доступен по другому URI, указанный в поле Location заголовка.
         * Этот код был введён вместе с 303 вместо 302-го для избежания неоднозначности.
         *
         * Если метод не GET или HEAD, Спросить у пользователя подтверждения и запросить другой ресурс исходным методом.
         */
        307 => [
            'code'          => 307,
            'title'         => '307 Temporary Redirect',
            'description'   => 'Ресурс временно доступен по другому адресу.',
            'requireParams' => ['Location'],
        ],

        /**
         * Сервер обнаружил в запросе клиента синтаксическую ошибку.
         */
        400 => [
            'code'          => 400,
            'title'         => '400 Bad Request',
            'description'   => 'Синтаксическая ошибка в Вашем запросе.',
        ],

        /**
         * Для доступа к запрашиваемому ресурсу требуется аутентификация.
         * В заголовке ответ должен содержать поле WWW-Authenticate с перечнем условий аутентификации.
         * Клиент может повторить запрос,
         * включив в заголовок сообщения поле Authorization с требуемыми для аутентификации данными.
         *
         * С выдачей заголовка WWW-Authenticate есть много нюансов, да и у нас не используется www-аутентификация,
         * так что метод sendHeaderWwwAuthenticate() предлагается реализовать в будущем самостоятельно.
         */
        401 => [
            'code'          => 401,
            'title'         => '401 Unauthorized',
            'description'   => 'Для продолжения требуется аутентификация.',
            'requireParams' => 'wwwAuthenticate',
        ],

        /**
         * Предполагается использовать в будущем. В настоящий момент не используется.
         * Этот код предусмотрен для платных пользовательских сервисов, а не для хостинговых компаний.
         * Имеется в виду,
         * что эта ошибка не будет выдана хостинговым провайдером в случае просроченной оплаты его услуг.
         */
        402 => [
            'code'          => 402,
            'title'         => '402 Payment Required',
            'description'   => 'Доступ к платному контенту ограничен.',
        ],

        /**
         * Сервер понял запрос,
         * но он отказывается его выполнять из-за ограничений в доступе для клиента к указанному ресурсу.
         * Если для доступа к ресурсу требуется аутентификация средствами HTTP,
         * то сервер вернёт ответ 401 или 407 при использовании прокси.
         * В противном случае ограничения были заданы администратором сервера или разработчиком веб-приложения
         * и могут быть любыми в зависимости от возможностей используемого программного обеспечения.
         * В любом случае клиенту следует сообщить причины отказа в обработке запроса.
         * Наиболее вероятными причинами ограничения может послужить попытка доступа к системным ресурсам веб-сервера
         * (например, файлам .htaccess или .htpasswd) или к файлам,
         * доступ к которым был закрыт с помощью конфигурационных файлов, требование аутентификации не средствами HTTP,
         * например, для доступа к админке или разделу для зарегистрированных пользователей
         * либо сервер не удовлетворён IP-адресом клиента, например, при блокировках.
         */
        403 => [
            'code'          => 403,
            'title'         => '403 Forbidden',
            'description'   => 'Доступ запрещен. Возможно, Вам требуется пройти авторизацию.',
        ],

        /**
         * Самая распространенная ошибка при пользовании Интернетом,
         * основная причина — ошибка в написании адреса Web-страницы.
         * Сервер понял запрос, но не нашёл соответствующего ресурса по указанному URI.
         * Если серверу известно, что по этому адресу был документ, то ему желательно использовать код 410.
         * Ответ 404 может использоваться вместо 403,
         * если требуется тщательно скрыть от посторонних глаз определённые ресурсы.
         */
        404 => [
            'code'          => 404,
            'title'         => '404 Not Found',
            'description'   => 'Ресурс не найден.',
        ],

        /**
         * Указанный клиентом метод нельзя применить к текущему ресурсу.
         * В ответе сервер должен указать доступные методы в заголовке Allow, разделив их запятой.
         * Эту ошибку сервер должен возвращать, если метод ему известен,
         * но он не применим именно к указанному в запросе ресурсу.
         * Если же указанный метод не применим на всём сервере, то клиенту нужно вернуть код 501 (Not Implemented).
         *
         * Применимо именно к методу HTTP (GET, POST, PUT, DELETE и т.д.).
         */
        405 => [
            'code'          => 405,
            'title'         => '405 Method Not Allowed',
            'description'   => 'Данный метод не применим к текущему ресурсу.',
            'requireParams' => ['Allow'],
        ],

        /**
         * запрошенный URI не может удовлетворить переданным в заголовке характеристикам.
         * Если метод был не HEAD, то сервер должен вернуть список допустимых характеристик для данного ресурса.
         */
        406 => [
            'code'          => 406,
            'title'         => '406 Not Acceptable',
            'description'   => 'URI не удовлетворяет переданным в заголовке характеристикам.',
        ],

        /**
         * Ответ аналогичен коду 401 за исключением того, что аутентификация производится для прокси-сервера.
         * Механизм аналогичен идентификации на исходном сервере.
         */
        407 => [
            'code'          => 407,
            'title'         => '407 Proxy Authentication Required',
            'description'   => 'Требуется аутентификация на прокси-сервере.',
        ],

        /**
         * Время ожидания сервером передачи от клиента истекло.
         * Клиент может повторить аналогичный предыдущему запрос в любое время.
         * Например, такая ситуация может возникнуть при загрузке на сервер объёмного файла методом POST или PUT.
         * В какой-то момент передачи источник данных перестал отвечать,
         * например, из-за повреждения компакт-диска или потери связи с другим компьютером в локальной сети.
         * Пока клиент ничего не передаёт, ожидая от него ответа, соединение с сервером держится.
         * Через некоторое время сервер может закрыть соединение со своей стороны,
         * чтобы дать возможность другим клиентам сделать запрос.
         * Этот ответ не возвращается, когда клиент принудительно остановил передачу по команде пользователя
         * или соединение прервалось по каким-то иным причинам, так как ответ уже послать невозможно.
         */
        408 => [
            'code'          => 408,
            'title'         => '408 Request Timeout',
            'description'   => 'Время ожидания ответа истекло.',
        ],

        /**
         *  Запрос не может быть выполнен из-за конфликтного обращения к ресурсу.
         * Такое возможно, например, когда два клиента пытаются изменить ресурс с помощью метода PUT.
         */
        409 => [
            'code'          => 409,
            'title'         => '409 Conflict',
            'description'   => 'Конфликт доступа к ресурсу: кто-то другой пытается изменить его одновременно с Вами.',
        ],

        /**
         * Такой ответ сервер посылает, если ресурс раньше был по указанному URL, но был удалён и теперь недоступен.
         * Серверу в этом случае неизвестно и местоположение альтернативного документа, например, копии).
         * Если у сервера есть подозрение, что документ в ближайшее время может быть восстановлен,
         * то лучше клиенту передать код 404.
         */
        410 => [
            'code'          => 410,
            'title'         => '410 Gone',
            'description'   => 'Ресурс удален.',
        ],

        /**
         * Для указанного ресурса клиент должен указать Content-Length в заголовке запроса.
         * Без указания этого поля не стоит делать повторную попытку запроса к серверу по данному URI.
         * Такой ответ естественен для запросов типа POST и PUT.
         * Например, если по указанному URI производится загрузка файлов, а на сервере стоит ограничение на их объём.
         * Тогда разумней будет проверить в самом начале заголовок Content-Length и сразу отказать в загрузке,
         * чем провоцировать бессмысленную нагрузку, разрывая соединение,
         * когда клиент действительно пришлёт слишком объёмное сообщение.
         */
        411 => [
            'code'          => 411,
            'title'         => '411 Length Required',
            'description'   => 'Клиент должен указать размер загружаемого контента.',
        ],

        /**
         * Возвращается, если ни одно из условных полей заголовка запроса не было выполнено.
         */
        412 => [
            'code'          => 412,
            'title'         => '412 Precondition Failed',
            'description'   => 'Ни одно из условных полей заголовка запроса не было выполнено.',
        ],

        /**
         * Возвращается в случае, если сервер отказывается обработать запрос
         * по причине слишком большого размера тела запроса. Сервер может закрыть соединение,
         * чтобы прекратить дальнейшую передачу запроса. Если проблема временная,
         * то рекомендуется в ответ сервера включить заголовок Retry-After с указанием времени,
         * по истечении которого можно повторить аналогичный запрос.
         */
        413 => [
            'code'          => 413,
            'title'         => '413 Request Entity Too Large',
            'description'   => 'Слишком большой размер тела запроса.',
//            'requireParams' => ['Retry-After'],
        ],

        /**
         * Сервер не может обработать запрос из-за слишком длинного указанного URL. Такую ошибку можно спровоцировать,
         * например, когда клиент пытается передать длинные параметры через метод GET, а не POST.
         */
        414 => [
            'code'          => 414,
            'title'         => '414 Request-URI Too Long',
            'description'   => 'Слишком длинный URL запроса.',
        ],

        /**
         * По каким-то причинам сервер отказывается работать с указанным типом данных при данном методе.
         */
        415 => [
            'code'          => 415,
            'title'         => '415 Unsupported Media Type',
            'description'   => 'Неподдерживаемый тип контента.',
        ],

        /**
         * В поле Range заголовка запроса был указан диапазон за пределами ресурса и отсутствует поле If-Range.
         * Если клиент передал байтовый диапазон,
         * то сервер может вернуть реальный размер в поле Content-Range заголовка.
         * Данный ответ не следует использовать при передаче типа multipart/byteranges
         */
        416 => [
            'code'          => 416,
            'title'         => '416 Requested Range Not Satisfiable',
            'description'   => 'Запрошенный диапазон превышает размер контента.',
        ],

        /**
         * По каким-то причинам сервер не может удовлетворить значению поля Expect заголовка запроса.
         */
        417 => [
            'code'          => 417,
            'title'         => '417 Expectation Failed',
            'description'   => 'Expectation Failed!',
        ],

        /**
         * Этот код был введен в 1998 году как одна из традиционных первоапрельских шуток IETF.
         * Не ожидается, что данный код будет поддерживаться реальными серверами.
         * Однако, дорогие коллеги вполне могут запилить с этим статусом что-нибудь годное, интересное.
         */
        418 => [
            'code'          => 418,
            'title'         => '418 I\'m a teapot',
            'description'   => 'I\'m a teapot!',
        ],

        /**
         * Целевой ресурс из запроса заблокирован от применения к нему указанного метода
         */
        423 => [
            'code'          => 423,
            'title'         => '423 Locked',
            'description'   => 'Указанный метод нельзя применять к данному ресурсу.',
        ],

        /**
         * Сервер указывает клиенту на необходимость обновить протокол.
         * Заголовок ответа должен содержать правильно сформированные поля Upgrade и Connection.
         */
        426 => [
            'code'          => 426,
            'title'         => '426 Upgrade Required',
            'description'   => 'Хорошее начало!',
            'requireParams' => ['Upgrade', 'Connection'],
        ],

        /**
         * Клиент попытался отправить слишком много запросов за короткое время,
         * что может указывать, например, на попытку DoS-атаки.
         * Может сопровождаться заголовком Retry-After, указывающим, через какое время можно повторить запрос.
         */
        429 => [
            'code'          => 429,
            'title'         => '429 Too Many Requests',
            'description'   => 'Слишком много запросов за короткое время.',
            'requireParams' => ['Retry-After'],
        ],

        /**
         * Доступ к ресурсу закрыт по юридическим причинам,
         * например, по требованию органов государственной власти
         * или по требованию правообладателя в случае нарушения авторских прав.
         * Код ошибки является отсылкой к роману Рэя Брэдбери «451 градус по Фаренгейту».
         */
        451 => [
            'code'          => 451,
            'title'         => '451 Unavailable For Legal Reasons',
            'description'   => 'Доступ к ресурсу закрыт по требованию правообладателя.',
        ],

        /**
         * Коды 5xx выделены под случаи неудачного выполнения операции по вине сервера.
         * Для всех ситуаций, кроме использования метода HEAD,
         * сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.
         */

        /**
         * Любая внутренняя ошибка сервера, которая не входит в рамки остальных ошибок класса.
         */
        500 => [
            'code'          => 500,
            'title'         => '500 Internal Server Error',
            'description'   => 'Внутренняя ошибка сервера.',
        ],

        /**
         * Сервер не поддерживает возможностей, необходимых для обработки запроса.
         * Типичный ответ для случаев, когда сервер не понимает указанный в запросе метод.
         * Если же метод серверу известен, но он не применим к данному ресурсу, то нужно вернуть ответ 405.
         *
         * Применимо именно к методу HTTP (GET, POST, PUT, DELETE и т.д.).
         */
        501 => [
            'code'          => 501,
            'title'         => '501 Not Implemented',
            'description'   => 'Указанный HTTP-метод не поддерживается сервером.',
        ],

        /**
         * Сервер, выступая в роли шлюза или прокси-сервера,
         * получил недействительное ответное сообщение от вышестоящего сервера.
         */
        502 => [
            'code'          => 502,
            'title'         => '502 Bad Gateway',
            'description'   => 'Bad Gateway.',
        ],

        /**
         * Сервер временно не имеет возможности обрабатывать запросы по техническим причинам
         * (обслуживание, перегрузка и прочее).
         * В поле Retry-After заголовка сервер может указать время,
         * через которое клиенту рекомендуется повторить запрос.
         * Хотя во время перегрузки очевидным кажется сразу разрывать соединение,
         * эффективней может оказаться установка большого значения поля Retry-After
         * для уменьшения частоты избыточных запросов.
         */
        503 => [
            'code'          => 503,
            'title'         => '503 Service Unavailable',
            'description'   => 'Сервер находится на обслуживании. Это временно. Повторите запрос позднее.',
            'requireParams' => ['Retry-After'],
        ],

        /**
         * Сервер в роли шлюза или прокси-сервера не дождался ответа от вышестоящего сервера
         * для завершения текущего запроса.
         */
        504 => [
            'code'          => 504,
            'title'         => '504 Gateway Timeout',
            'description'   => 'Не получен ответ от вышестоящего сервера.',
        ],

        /**
         * Сервер не поддерживает или отказывается поддерживать указанную в запросе версию протокола HTTP.
         */
        505 => [
            'code'          => 505,
            'title'         => '505 HTTP Version Not Supported',
            'description'   => 'Указанная версия HTTP не поддерживается сервером.',
        ],
    ];

    protected function _httpStatus($code)
    {
        if (!isset(self::$_httpStatuses[$code]))
        {
            throw new Exception(__METHOD__ . ' requires a valid HTTP status code');
        }
        return self::$_httpStatuses[$code];
    }

    /**
     * Обработать значения параметров заголовков
     *
     * По каждому назначенному параметру будет вызван метод присвоения соответствующего заголовка
     * (если такой метод существует в данном классе).
     *
     * @param array $params  Обрабатываемые параметры
     * @param bool  $replace Заменять ли предыдущий аналогичный заголовок
     *
     * @return $this
     * @throws Exception в случае, если значение одного из параметров не строковое
     */
    protected function _processParams(array $params = [], $replace = true)
    {
        foreach ($params as $key => $value)
        {
            if (!is_string($value))
            {
                throw new Exception(__METHOD__ . ' requires a second argument to be an array of string values');
            }
            $methodName = 'sendHeader' . str_replace('-', '', $key);
            if (method_exists($this, $methodName))
            {
                $this->$methodName($value, $replace);
            }
        }
        return $this;
    }

    public function sendHeaderAllow($allow, $replace = true)
    {
        header('Allow: ' . $allow, $replace);
        return $this;
    }

    public function sendHeaderContentRange($range, $replace = true)
    {
        header('Content-Range: ' . $range, $replace);
        return $this;
    }

    /**
     * @param int   $code    Цифровой код HTTP-статуса
     * @param bool  $replace
     * @param array $params
     *
     * @return $this
     * @throws Exception
     */
    public function sendHeaderHttpStatus($code, $replace = true, array $params = [])
    {
        if (headers_sent())
        {
            throw new Exception('Headers already sent before ' . __METHOD__);
        }
        $status = $this->_httpStatus($code);
        header($status['title'], $replace, $status['code']);
        if (is_array($status['requireParams']))
        {
            foreach($status['requireParams'] as $value)
            {
                if (!isset($params[$value]))
                {
                    throw new Exception(
                        __METHOD__ . ' requires to set ' . implode($value, ', ')
                        . ' params for ' . $code . ' http status'
                    );
                }
            }
            $this->_processParams($params, $replace);
        }
        return $this;
    }

    public function sendHeaderLocation($url, $replace = true)
    {
        header('Location: ' . $url, $replace);
        return $this;
    }
} 